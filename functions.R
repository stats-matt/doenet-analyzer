#Functions
#These are functions used by the server for the Doenet stats analyzer

#======================load data=============================================
load_data <- function(query) {
  tmp_events <- data.frame()
  for (i in 1:length(unlist(query))) {
    raw <-  stream_in(file(
      paste0(
        "https://www.doenet.org/api/getEventData.php?doenetId[]=",
        query[[i]]
      )
    ))
    new_events <-  raw$events[[1]]
    tmp_events <- bind_rows(tmp_events, new_events)
  }
  return(tmp_events)
}


#======================clean_events=============================================
#This function does most of the heavy lifting of cleaning the events data
#That consists of getting rid of events outside of date range, determining which
#event came from which version of the activity, and unpacking columns containing
#JSON strings.

clean_events <- function(events, min_date, max_date) {
  events <- # remove visible verbs to keep the data smallish
    events %>%
    filter(verb != "isVisible")
  
  events <-
    #This block adds the timestamp column to the cleaned data set
    events %>%
    group_by(userId) %>%
    mutate(timestamp = anytime(timestamp)) %>%
    mutate(time_person = timestamp - min(timestamp)) %>%
    ungroup() %>%
    mutate(time_activity = timestamp - min(timestamp))# %>%
  #filter((timestamp > min_date) & (timestamp < max_date))
  
  events <- # this separates the context, object, and result columns
    events %>%
    mutate(new = map(context, ~ fromJSON(.) %>% as.data.frame())) %>%
    unnest_wider(new) %>%
    mutate(new = map(object, ~ fromJSON(.) %>% as.data.frame())) %>%
    unnest_wider(new) %>%
    mutate(response = map(result, ~ fromJSON(.))) %>%
    unnest_wider(response)
  
  #To solve the problem of multiple types in the response column we used code from
  # the following stackoverflow link:
  # https://stackoverflow.com/questions/27668266/dplyr-change-many-data-types
  #
  # events <-
  #   events %>%
  #   separate(componentName, into = c(NA, "section", "answer", "type"))
  #
  # events <-
  #   events %>%
  #   filter(!is.na(documentCreditAchieved))
  
  
  
  # this has been replaced by the line below it
  # events$version_num <-  NA
  # processed <-
  #   events %>% group_by(activityCid) %>% summarize(min_stamp = min(timestamp))
  # processed <-  processed[order(processed$min_stamp),]
  # dict <- c(1:nrow(processed))
  # names(dict) = processed$activityCid
  # for (i in (1:(nrow(events)))) {
  #   working_id = events[[i, 4]]
  #   events[[i, ncol(events)]] = dict[working_id]
  # }
  
  events$version_num <-
    events$activityCid %>% as.factor() %>% as.numeric()
  
  return(events)
}

#=================summarize_events==============================================
#This creates the summary data
#We start with the cleaned data and select the relevant columns
#Then we group by userID and pageNumber and version_num
#Then the summarize_all gives us the max value (so the max time it took to
# answer that problem on that page, or something like that)
# pivot_longer sets up a column with all the problem names (drawn from the
# X1 - Xn columns in the cleaned set) and then takes the values from those
# Columns and drops them into the score column of the summary
summarize_events <- function(data) {
  out <-
    data %>%
    select(
      userId,
      timestamp,
      time_person,
      time_activity,
      pageNumber,
      version_num,
      response,
      verb,
      item,
      itemCreditAchieved,
      pageCreditAchieved,
      pageVariantIndex,
      activityVariantIndex
    ) %>%
    filter(verb == "submitted") %>%
    group_by(item,
             pageNumber,
             version_num,
             pageVariantIndex,
             activityVariantIndex) %>%
    mutate(avg = mean(itemCreditAchieved)) %>%
    ungroup() %>%
    add_count(response,
              item,
              version_num,
              pageVariantIndex,
              activityVariantIndex)
  
  return(out)
}
#====================pull_dates=================================================
pull_dates <- function(events) {
  out <- events %>% select(timestamp)
  out <- anytime(out$timestamp)
  return(out)
}
#==================pull_versions================================================
pull_versions <- function(events) {
  out <- events %>% distinct(activityCid) %>% nrow()
  return(out)
}
#================version_filter=================================================
version_filter <- function(cleaned, input_version) {
  out <- cleaned #%>% filter(cleaned$version_num == input_version)
  return(out)
}
